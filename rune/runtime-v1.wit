/// Metadata describing a single node in the Machine Learning pipeline.
resource metadata {
    /// Create a new metadata object with the provided name and version number.
    ///
    /// The name should typically be one or two words that concisely describe
    /// the node and will be used as the human-friendly label shown to users
    /// when referring to it.
    static new: function(name: string, version: string) -> metadata
    /// A human-friendly description of the node.
    ///
    /// The text may include markdown.
    set-description: function(description: string)
    /// A repository containing this node's source code.
    set-repository: function(url: string)
    /// The node's home page.
    ///
    /// This will typically point to a `README` file or a page on the internet
    /// that users can go to when they want to find out more about the node.
    set-homepage: function(url: string)
    /// Associate this node with a particular tag.
    ///
    /// Tags are typically used to assist in search and filtering.
    add-tag: function(tag: string)
    /// Arguments this node accepts.
    add-argument: function(arg: argument-metadata)
    /// Information about this node's input tensors.
    add-input: function(metadata: tensor-metadata)
    /// Information about this node's output tensors.
    add-output: function(metadata: tensor-metadata)
}

/// Information about a node's argument.
resource argument-metadata {
    /// Create a new named argument.
    static new: function(name: string) -> argument-metadata
    /// A human-friendly description of the argument.
    ///
    /// The text may include markdown.
    set-description: function(description: string)
    /// A useful default value for this argument.
    set-default-value: function(default-value: string)
    add-hint: function (hint: argument-hint)
}

/// Information about a tensor.
resource tensor-metadata {
    /// Create a new named tensor.
    static new: function(name: string) -> tensor-metadata
    /// A human-friendly description of the tensor.
    ///
    /// The text may include markdown.
    set-description: function(description: string)
    /// Add a hint that provides the runtime with contextual information about
    /// this node.
    add-hint: function(hint: tensor-hint)
}

/// Hints that can be used by the runtime when inspecting a tensor.
resource tensor-hint

/// Hint to the runtime that a tensor may be displayed as an image.
interpret-as-image: function() -> tensor-hint

/// Hint to the runtime that a tensor may be interpreted as an audio clip.
interpret-as-audio: function() -> tensor-hint

/// Hint that a tensor may have a particular shape and the element types it
/// supports.
///
/// Note: This hint will be removed in the future in favour of a more flexible
/// mechanism.
supported-shapes: function(supported-element-types: list<element-type>, dimensions: dimensions) -> tensor-hint

/// The various types of values a tensor may contain.
enum element-type {
    %u8,
    %i8,
    %u16,
    %i16,
    %u32,
    %i32,
    %f32,
    %u64,
    %i64,
    %f64,
    /// A string as UTF-8 encoded bytes.
    utf8,
}

/// The dimensions that a tensor may have.
variant dimensions {
    /// There can be an arbitrary number of dimensions with arbitrary sizes.
    dynamic,
    /// The tensor has a fixed rank with the provided dimension sizes.
    ///
    /// If a particular dimension's length is zero, that is interpreted as the
    /// dimension being allowed to have any arbitrary length.
    fixed(list<u32>),
}

/// Hints that can be used by the runtime when inspecting an argument
resource argument-hint

/// Hint to the runtime that an argument may be interpreted as a number in `[min, max]`
interpret-as-number-in-range: function(min: string, max: string) -> argument-hint

/// Hint to the runtime that an argument may be interpreted as a string in a defined list
interpret-as-string-in-enum: function(string-enum: list<string>) -> argument-hint

/// Hint to the runtime that an argument may be interpreted as a non-negative number
non-negative-number: function() -> argument-hint

/// How will an argument be interpreted?
///
/// All nodes receive arguments as strings. This enum lets the node hint to the
/// runtime that an argument may be formatted in a particular way.
enum argument-type {
    /// An unsigned integer.
    unsigned-integer,
    /// An integer, possibly signed.
    integer,
    /// A decimal number.
    float,
    /// A short string.
    %string,
    /// A multi-line string.
    long-string,
}

/// Tell the runtime that this argument may have a certain type.
supported-argument-type: function(hint: argument-type) -> argument-hint

/// Register a node type with the runtime.
register-node: function(metadata: metadata)

/// Contextual information used when determining the ML / Data Processing pipeline.
/// This is defined by the runtime but available for logic within the container (rune)
resource graph-context {
    /// Get the graph context for a particular node.
    ///
    /// Note: this should only be used from within the `graph()` function.
    static for-node: function(node-id: string) -> option<graph-context>
    // Name of the argument and returns the value of the argument
    // Analogy: Getting an environment variable docker container
    get-argument: function(name: string) -> option<string>
    add-input-tensor: function(
        name: string,
        element-type: element-type,
        dimensions: dimensions,
    )
    add-output-tensor: function(
        name: string,
        element-type: element-type,
        dimensions: dimensions,
    )
}

/// Contextual information provided to the guest when evaluating a node.
resource kernel-context {
    /// Get the kernel context for a particular node.
    ///
    /// Note: this should only be used from within the `kernel()` function.
    static for-node: function(node-id: string) -> option<kernel-context>
    /// Get a named argument.
    get-argument: function(name: string) -> option<string>
    /// Get one of this node's input tensors by name.
    get-input-tensor: function(name: string) -> option<tensor>
    /// Set one of this node's input tensors by name.
    set-output-tensor: function(name: string, tensor: tensor)
    /// Get a global input tensor.
    ///
    /// Note: these tensors live in a separate namespace from a node's normal
    /// input and output tensors.
    get-global-input: function(name: string) -> option<tensor>
    /// Set a global input tensor.
    ///
    /// Note: these tensors live in a separate namespace from a node's normal
    /// input and output tensors.
    set-global-output: function(name: string, tensor: tensor)
}

/// The shape of a concrete tensor.
record shape {
    element-type: element-type,
    dimensions: dimensions,
}

/// A tensor with fixed dimensions.
record tensor {
    /// The type of data this tensor contains.
    element-type: element-type,
    /// The tensor's dimensions.
    dimensions: list<u32>,
    /// The raw bytes used by this tensor, as little-endian values.
    ///
    /// Note: because string tensors are represented using a variable-length
    /// encoding where each string is prefixed by its length as a little-endian
    /// `u32`.
    buffer: list<u8>,
}

/// The verbosity level used while logging.
enum log-level {
    trace,
    debug,
    info,
    warn,
    error,
    /// An unrecoverable error occurred.
    fatal,
}

/// A value that can be used when logging structured data.
variant log-value {
    null,
    boolean(bool),
    integer(s64),
    float(f64),
    %string(string),
}

/// Metadata for a log event.
record log-metadata {
    name: string,
    target: string,
    level: log-level,
    file: option<string>,
    line: option<u32>,
    module: option<string>,
}

/// A list of key-value pairs used when logging structured data.
type log-value-map = list<tuple<string, log-value>>

/// Check whether a particular message would be logged, allowing the guest to
/// avoid potentially expensive work.
is-enabled: function(metadata: metadata) -> bool

/// Record a log message with some structured data.
log: function(metadata: metadata, message: string, data: log-value-map)

resource model {
    /// Use the runtime to load a model.
    ///
    /// The `model-format` argument tells the runtime what type of model is
    /// being loaded. Arguments, a list of key-value pairs, may be used to
    /// modify the loading process (e.g. to request hardware acceleration).
    static load: function(
        model-format: string,
        model: list<u8>,
        arguments: list<tuple<string, string>>,
    ) -> expected<model, model-load-error>
    infer: function(inputs: list<tensor>) -> expected<list<tensor>, model-infer-error>
    /// The shape of this model's input tensors.
    inputs: function() -> list<shape>
    /// The shape of this model's output tensors.
    outputs: function() -> list<shape>
}

variant model-load-error {
    other(string),
}

variant model-infer-error {
    other(string),
}
